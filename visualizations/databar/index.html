<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

circle {
  fill: steelblue;
  stroke: #fff;
  stroke-width: 3px;
}

body {
    padding: 20px;
}
.slides {
    list-style: none;
    margin: -20px;
    padding: 0;
}
.slide {
    color: #FFF;
}

.slide-placeholder {
    background: #DADADA;
    position: relative;
}
.slide-placeholder:after {
    content: " ";
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 15px;
}
line {
  stroke: #000;
  stroke-width: 1px;
  opacity: 0.05;
}

/* Style the button that is used to open and close the collapsible content */
.collapsible {
  background-color: #eee;
  color: #444;
  cursor: pointer;
  padding: 9px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

/* Style the collapsible content. Note: hidden by default */
.content {
  padding: 0 18px;
  overflow: hidden;
  background-color: #f1f1f1;
}

/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
.active, .collapsible:hover {
  background-color: #ccc;
}

</style>
<script src="../nodelink/lib/d3.js"></script>
<script src="../../core/networkcube.js"></script>
<script src="../../web/lib/jquery.js"></script>
<script src="../../visualizations/3dbrain/lib/jquery-ui-1.10.2.js"></script>
<script src="../../visualizations/nodelink/nodelink.js"></script>
<script src="lib/hcluster.min.js"></script>
<ul class="slides"></ul>

<script>
$(".slides").sortable({
     placeholder: 'slide-placeholder',
    axis: "y",
    revert: 150,
    start: function(e, ui){

        placeholderHeight = ui.item.outerHeight();
        ui.placeholder.height(placeholderHeight + 15);
        $('<div class="slide-placeholder-animator" data-height="' + placeholderHeight + '"></div>').insertAfter(ui.placeholder);

    },
    change: function(event, ui) {

        ui.placeholder.stop().height(0).animate({
            height: ui.item.outerHeight() + 15
        }, 300);

        placeholderAnimatorHeight = parseInt($(".slide-placeholder-animator").attr("data-height"));

        $(".slide-placeholder-animator").stop().height(placeholderAnimatorHeight + 15).animate({
            height: 0
        }, 300, function() {
            $(this).remove();
            placeholderHeight = ui.item.outerHeight();
            $('<div class="slide-placeholder-animator" data-height="' + placeholderHeight + '"></div>').insertAfter(ui.placeholder);
        });

    },
    stop: function(e, ui) {

        $(".slide-placeholder-animator").remove();

    },
});

width = window.innerWidth -30
//height =

function drawLineGraph(points, circleColor, id, title, min, max){

  var svg = d3.select(".slides")
      .append("div");


  var titlebar = svg.append("li")
      .text("+ " + title)
      .attr("class", "collapsible")
      .attr("fill", "black")
      .style("text-anchor", "middle")
      .style("font-family", "Helvetica")
      .attr("transform", "translate( 40, 20 )")

  var next = svg.append("li").append("svg")
      .attr("class", "slide content")
      .attr("width", width -30)
      .attr("height", "65px");

  var yScale = d3.scale.linear()
  	        .domain([min, max])
            .range([40, 0]);

  var yAxis = d3.svg.axis()
            .orient("left")
            .scale(yScale)
            .ticks(3);

  var yAxisLabel = next.append("g")
      .attr("transform", function(d) { return "translate(30, 10)"; })
      .call(yAxis);

  var chart = next.append("g")
      .style("height", "100px")
      .attr("transform", function(d) { return "translate(30,5)"; });


  var path = chart.append("path")
      .data([points])
      .style("stroke", circleColor)
      .style("fill", circleColor)
      .style("fill-opacity", 0.8)
      .style("float", "right")
      .attr("d", d3.svg.line()
      .tension(0) // Catmullâ€“Rom
      .interpolate("linear"));

  chart.selectAll(".point")
    .data(points)
    .enter().append("circle")
    .attr("r", 2)
    .style("fill", circleColor)
    .style("stroke", circleColor)
    .attr("transform", function(d) { return "translate(" + d + ")"; })
    .on("click", function(d) {
      console.log("Clicked circle " + d)
    });

  chart.selectAll(".line")
    .data(points)
    .enter().append("line")
    .attr("x1", function(d) { return d[0] })
    .attr("x2", function(d) { return d[0] })
    .attr("y1", 0)
    .attr("y2", 50)
    .attr("stroke-dasharray", function(d) { return (d + 1) + ",5"});

  var circleGroup = chart.append("g")

  var circle = circleGroup.append("circle")
      .attr("r", 7)
      .style("fill", circleColor)
      .style("stroke", circleColor)
      .style("opacity", 0.5)
      .attr("transform", "translate(" + points[0] + ")");

  var circle2 = circleGroup.append("text")
  .text("")
  .style("color", "black")
  .style("font-family", "Helvetica")
  .attr({
    "text-anchor": "middle",
    "font-size": 20
  });


  //var text = svg.append("text").text("hallo")

  return {id: id, path: path, circle: circleGroup}
}

var dgraph = networkcube.getDynamicGraph();

var labels = dgraph.timeArrays.label
int_dates = labels.map(Date.parse)
gaps_in_days = [0]

for(i=0;i<int_dates.length-1;i++){
  gap = Math.round((int_dates[i+1] - int_dates[i])/86400000) //days
  gaps_in_days.push(gap)
}
console.log(gaps_in_days)

nodeSetLengthAtEachPoint = [];
for(i=0; i<dgraph.timeArrays.links.length; i++){
    let nodesAtThisPoint = new Set();
    for(j=0; j<dgraph.timeArrays.links[i].length; j++){
        nodesAtThisPoint.add( dgraph.linkArrays.source[dgraph.timeArrays.links[i][j]] )
        nodesAtThisPoint.add( dgraph.linkArrays.target[dgraph.timeArrays.links[i][j]] )
    }
    nodeSetLengthAtEachPoint.push(nodesAtThisPoint.size)
    //this could be useful later to get the connected nodes a each time point
    //Dont think this works because it only shows when new nodes are added, not when they're removedi
}
console.log(nodeSetLengthAtEachPoint)

var sum = gaps_in_days.reduce(function(a, b) { return a + b; }, 0);
step_size = gaps_in_days.length / sum

const normalised_gaps_in_days = gaps_in_days.map(x => x * step_size);
console.log(normalised_gaps_in_days)
normalised_gaps_X_coords = []
sumSoFar = 0
for(i=0;i<normalised_gaps_in_days.length;i++){
  sumSoFar += normalised_gaps_in_days[i]
  normalised_gaps_X_coords.push(sumSoFar)
}
console.log(normalised_gaps_X_coords)


numberOfLinksAtEachTimeJump = [];
timesForLinks = dgraph.timeArrays.label;
for(i=0; i < dgraph.timeArrays.links.length; i++){
    numberOfLinksAtEachTimeJump.push(dgraph.timeArrays.links[i].length);
}
function calculateDensity(edges, nodes){
  ret = []
  i = 0
  while(i < edges.length){
    ret.push( (edges[i]) / (nodes[i] * (nodes[i] - 1)) )
    i += 1
  }
  return ret
}

function getStateOfGrapghAtT(t){
  edges = dgraph.timeArrays.links[t]
  ret_edges = []
  ret_nodes = new Set([])
  for(i=0;i<edges.length;i++){
    edge = edges[i]
    source = dgraph.linkArrays.source[edge]
    target = dgraph.linkArrays.target[edge]
    ret_edges.push([source, target])
    ret_nodes.add(source)
    ret_nodes.add(target)
    //console.log("Edge "+edges[i] + " from " + source + " to " + target)
  }
  ret_nodes = Array.from(ret_nodes);
  return {"edges": ret_edges, "nodes": ret_nodes}
}

function getFormattedStateOfGrapghAtT(t){
  edges = dgraph.timeArrays.links[t]
  ret = {}
  ret_nodes = new Set([])
  for(i=0;i<edges.length;i++){
    edge = edges[i]
    source = dgraph.linkArrays.source[edge]
    target = dgraph.linkArrays.target[edge]
    ret_nodes.add(source)
    ret_nodes.add(target)
    if(ret[source]){
      ret[source].push(target)
    }else{
      ret[source] = [target]
    }
    if(!(ret[target])){
      ret[target] = []
    }
    if(ret[target]){
      ret[target].push(source)
    }else{
      ret[target] = [source]
    }
    if(!(ret[source])){
      ret[source] = []
    }
  }
  console.log(ret)
  return {"graph": ret, "nodes": ret_nodes}
}

class Graph {
   constructor() {
      this.edges = {};
      this.nodes = [];
   }

   addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
   }

   addEdge(node1, node2, weight = 1) {
      this.edges[node1].push({ node: node2, weight: weight });
      this.edges[node2].push({ node: node1, weight: weight });
   }

   floydWarshallAlgorithm() {
      let dist = {};
      let maxSoFar = 0;
      for (let i = 0; i < this.nodes.length; i++) {
         dist[this.nodes[i]] = {};
         // For existing edges assign the dist to be same as weight
         this.edges[this.nodes[i]].forEach(e => (dist[this.nodes[i]][e.node] = e.weight));
         this.nodes.forEach(n => {
            // For all other nodes assign it to infinity
            if (dist[this.nodes[i]][n] == undefined)
            dist[this.nodes[i]][n] = Infinity;
            // For self edge assign dist to be 0
            if (this.nodes[i] === n) dist[this.nodes[i]][n] = 0;
         });
      }
      this.nodes.forEach(i => {
         this.nodes.forEach(j => {
            this.nodes.forEach(k => {
               // Check if going from i to k then from k to j is better
               // than directly going from i to j. If yes then update
               // i to j value to the new value
               if (dist[i][k] + dist[k][j] < dist[i][j])
                  dist[i][j] = dist[i][k] + dist[k][j];
               });
            });
         });
         //Can also return dist for all of them
         return dist;
   }
}

function diameterOfGraphAtT(t){
  let g = new Graph();
  graph = getStateOfGrapghAtT(t)
  edges = graph['edges']
  nodes = graph['nodes']
  for(i=0;i<nodes.length;i++){
    g.addNode(nodes[i])
  }
  for(i=0;i<edges.length;i++){
    g.addEdge(edges[i][0], edges[i][1])
  }
  dist = g.floydWarshallAlgorithm()
  diameter = 0
  for(var key in dist){
    val = dist[key]
    for(var key2 in val){
      if(val[key2] > diameter && isFinite(val[key2]) ){
        diameter = val[key2]
      }
    }
  }
  //console.log(dist)
  return diameter
}

allDiameters = []
for(j=0;j<60;j++){
  allDiameters.push(diameterOfGraphAtT(j))
}
console.log(allDiameters)

function getClusterCounts(){
  console.log("CLUSTER COUNTS")
  console.log(dgraph)
  var colorCluster = hcluster()
    .distance('euclidean') // support for 'euclidean' and 'angular'
    .linkage('avg')        // support for 'avg', 'max' and 'min'
    .verbose(true)         // false by default
    .posKey('rgbValue')    // 'position' by default
}

getClusterCounts()

var visited = {}
function dfs_visit_all_connected(node, graph){
  console.log("DFS - node = "+ node)
  var connected = graph[node]
  for(var i=0; i<connected.length; i++){
    console.log("DFS, visiting " + connected[i] + " i = "+ i + " seen already?: " + visited[connected[i]])
    if(visited[connected[i]] == false){
      visited[connected[i]] = true
      dfs_visit_all_connected(connected[i], graph)
    }
  }
  console.log("go back up?")
}

/*
Effectively - for every node in graph - mark it as visited
then visit all of it's connections. This is one connected component.
When repeating for the second node, if it hasn't already been visited then
the number of connected components will increase.
*/
function getNumberOfConnectedComponentsAtT(t){
  visited = {}
  //console.log("NUMBER OF CONNECTED COMPONENTS")
  formattedGraph = getFormattedStateOfGrapghAtT(t)
  graph = formattedGraph["graph"]
  nodes = Array.from(formattedGraph["nodes"])
  //console.log(graph)

  connected_components = 0
  //Set every node in the array to visited=false initially
  for(var i=0;i<nodes.length;i++){
    visited[nodes[i]] = false
  }
  for(var node in graph){
    //console.log("Init, visiting " + node + " seen already?: " + visited[node])
    if(visited[node] == false){
      visited[node] = true
      connected_components += 1
      //console.log("increasing CC")
      dfs_visit_all_connected(node, graph)
    }
  }
  //console.log("connected_components = " + connected_components)
  return connected_components
}
//Testing
//getNumberOfConnectedComponentsAtT(15) //2
//getNumberOfConnectedComponentsAtT(1) //1
allConnectedComponents = []
for(j=0;j<60;j++){
  allConnectedComponents.push(getNumberOfConnectedComponentsAtT(j))
}
console.log(allConnectedComponents)


function convertToCoords(x){
  len = x.length
  step = Math.ceil(width / len)
  var max = x.reduce(function(a, b) {
    return Math.max(a, b);
  });
  //console.log("YEEER" + x + " " + step + " " + max )
  ret = []
  ret.push([0,50])
  for(i=0; i<normalised_gaps_X_coords.length; i++){
    scaledY = x[i] / max * 50;
    ret.push([normalised_gaps_X_coords[i]*step, 50-scaledY])
    //console.log("pushing", [normalised_gaps_X_coords[i]*step, 50-scaledY])
  }
  ret.push([len*step, 50])
  ret.push([0,50])
  //console.log(ret)
  return ret
}

var originalpoints5 = allConnectedComponents
console.log("CHECKIT")
max = Math.max.apply(Math, originalpoints5)
var points5 = convertToCoords(allConnectedComponents);
graph5 = drawLineGraph(points5, "brown", 3, "Connected Components", 0, max)

var originalpoints4 = allDiameters
max = Math.max.apply(Math, originalpoints4)
var points4 = convertToCoords(allDiameters);
graph4 = drawLineGraph(points4, "purple", 3, "Diameter", 0, max)

var originalpoints3 = calculateDensity(numberOfLinksAtEachTimeJump, nodeSetLengthAtEachPoint)
max = Math.max.apply(Math, originalpoints3)
var points3 = convertToCoords(calculateDensity(numberOfLinksAtEachTimeJump, nodeSetLengthAtEachPoint));
graph3 = drawLineGraph(points3, "green", 3, "Density", 0, max)

var originalpoints2 = numberOfLinksAtEachTimeJump
max = Math.max.apply(Math, originalpoints2)
var points2 = convertToCoords(numberOfLinksAtEachTimeJump);
graph2 = drawLineGraph(points2, "blue", 2, "Links", 0, max)

var originalpoints1 = nodeSetLengthAtEachPoint
max = Math.max.apply(Math, originalpoints1)
var points1 = convertToCoords(nodeSetLengthAtEachPoint);
graph1 = drawLineGraph(points1, "red", 1, "Nodes", 0, max)

allGraphs = [graph1, graph2]

var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}


//transition();

function approximateXY(points, line, mouseX, trueLength){
  closest_point_to_cursor = points[0]
  var i;
  for(i=0; i<points.length; i++){
    if(Math.abs(mouseX - points[i][0]) <= Math.abs(mouseX - closest_point_to_cursor[0])){
      closest_point_to_cursor = points[i]
    }
  }
  if(closest_point_to_cursor[0] && closest_point_to_cursor[1]){
    return {x: closest_point_to_cursor[0], y: closest_point_to_cursor[1]}
  }else{
    return {x: 0, y: 0}
  }
}

function getYlabelFromyCoord(originalpoints, points, approx){
  console.log(originalpoints)
  points = points.slice(1, points.length - 2)
  console.log(points)
  console.log(approx.x)
  ylabel = "n/a"
  for(point in points){
    if(points[point][0] == approx.x){
      ylabel = "" + Math.round(originalpoints[point]  * 100) / 100
    }
  }
  return ylabel
}

function transition(originalpoints, points, graph, mouseX) {

  var pathLength = graph.path.node().getTotalLength();
  //console.log("LENGTH " + pathLength)
  //console.log("WIDTH " + width)
  //console.log("HEIGHT " + 50)
  pathLength = pathLength - (2*50) - width
  //console.log("TRUE LENGTH " + pathLength)
  cursor_prcnt = mouseX / width;

  X_ = cursor_prcnt * pathLength;
  pt = graph.path.node().getPointAtLength(X_);

  //console.log("width " + width)
  //console.log("cursor_prcnt " + cursor_prcnt)
  //console.log("Expected X " + cursor_prcnt * width)
  approx = approximateXY(points, graph.path.node(), mouseX, pathLength)
  //console.log("Approximated X" + approx)
  //console.log("Actual X " + pt.x)

  ylabel = getYlabelFromyCoord(originalpoints, points, approx)


  if(approx.x && approx.y){
    graph.circle.selectAll("circle").attr("transform", function(d) {
        return "translate(" + approx.x + "," + approx.y + ")"
    });
    graph.circle.selectAll("text").attr("transform", function(d) {
        graph.circle.selectAll("text").text(ylabel)
        return "translate(" + approx.x + "," + approx.y + ")"
    });
  }
}

function getMousePos(svg, evt) {
  return {
    x: evt.clientX,
    y: evt.clientY
  };
}

document.addEventListener('mousemove', function(evt) {
  var mousePos = getMousePos(document, evt);
  transition(originalpoints1, points1, graph1, mousePos.x);
  transition(originalpoints2, points2, graph2, mousePos.x);
  transition(originalpoints3, points3, graph3, mousePos.x);
  transition(originalpoints4, points4, graph4, mousePos.x);
  transition(originalpoints5, points5, graph5, mousePos.x);
}, false);

document.addEventListener('click', function(evt) {
  //can convert to timeArray first and last label
  initialTime = new Date('1960-12-13T12:00:00+00:00').getTime() / 1000
  finalTime = new Date('1992-06-03T12:00:00+01:00').getTime() / 1000
  console.log(initialTime)
  console.log(finalTime)
  console.log(event.clientX + " " + width)
  clicked_time_point = initialTime + (event.clientX/width * (finalTime - initialTime))
  console.log(clicked_time_point)
  parent.window.networkcube.timeRange(clicked_time_point *0.95, clicked_time_point*1.05, 1, true)
}, false);



</script>
