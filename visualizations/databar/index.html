<!DOCTYPE html>
<meta charset="utf-8">
<body>
<style>

path {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

circle {
  fill: steelblue;
  stroke: #fff;
  stroke-width: 3px;
}

body {
    padding: 20px;
}
.slides {
    list-style: none;
    margin: -20px;
    padding: 0;
}
.slide {
    color: #FFF;
}

.slide-placeholder {
    background: #DADADA;
    position: relative;
}
.slide-placeholder:after {
    content: " ";
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 15px;
}
line {
  stroke: #000;
  stroke-width: 1px;
  opacity: 0.05;
}

</style>
<script src="../nodelink/lib/d3.js"></script>
<script src="../../core/networkcube.js"></script>
<script src="../../web/lib/jquery.js"></script>
<script src="../../visualizations/3dbrain/lib/jquery-ui-1.10.2.js"></script>
<script src="../../visualizations/nodelink/nodelink.js"></script>
<script src="lib/hcluster.min.js"></script>
<ul class="slides"></ul>

<script>
$(".slides").sortable({
     placeholder: 'slide-placeholder',
    axis: "y",
    revert: 150,
    start: function(e, ui){

        placeholderHeight = ui.item.outerHeight();
        ui.placeholder.height(placeholderHeight + 15);
        $('<div class="slide-placeholder-animator" data-height="' + placeholderHeight + '"></div>').insertAfter(ui.placeholder);

    },
    change: function(event, ui) {

        ui.placeholder.stop().height(0).animate({
            height: ui.item.outerHeight() + 15
        }, 300);

        placeholderAnimatorHeight = parseInt($(".slide-placeholder-animator").attr("data-height"));

        $(".slide-placeholder-animator").stop().height(placeholderAnimatorHeight + 15).animate({
            height: 0
        }, 300, function() {
            $(this).remove();
            placeholderHeight = ui.item.outerHeight();
            $('<div class="slide-placeholder-animator" data-height="' + placeholderHeight + '"></div>').insertAfter(ui.placeholder);
        });

    },
    stop: function(e, ui) {

        $(".slide-placeholder-animator").remove();

    },
});

width = window.innerWidth -30
//height =

function drawLineGraph(points, circleColor, id, title){

  var svg = d3.select(".slides").append("li").attr("class", "slide").append("svg")
      .attr("width", width -30)
      .attr("height", 50);


  var path = svg.append("path")
      .data([points])
      .style("stroke", circleColor)
      .style("fill", circleColor)
      .style("fill-opacity", 0.8)
      .attr("d", d3.svg.line()
      .tension(0) // Catmullâ€“Rom
      .interpolate("linear"));

  svg.selectAll(".point")
    .data(points)
    .enter().append("circle")
    .attr("r", 2)
    .style("fill", circleColor)
    .style("stroke", circleColor)
    .attr("transform", function(d) { return "translate(" + d + ")"; });

  svg.selectAll(".line")
    .data(points)
    .enter().append("line")
    .attr("x1", function(d) { return d[0] })
    .attr("x2", function(d) { return d[0] })
    .attr("y1", 0)
    .attr("y2", 50)
    .attr("stroke-dasharray", function(d) { return (d + 1) + ",5"});

  var titleText = svg.append("text")
    .attr("fill", "black")
    .style("text-anchor", "middle")
    .text(title + " ".repeat(8-title.length) ) //trying to get titles to align
    .style("font-family", "Helvetica")
    .attr("transform", "translate( 40, 20 )");

  var circleGroup = svg.append("g")

  var circle = circleGroup.append("circle")
      .attr("r", 7)
      .style("fill", circleColor)
      .style("stroke", circleColor)
      .style("opacity", 0.5)
      .attr("transform", "translate(" + points[0] + ")");

  var circle2 = circleGroup.append("text")
  .text("HALLO")
  .style("color", "black")
  .style("font-family", "Helvetica")
  .attr({
    "text-anchor": "middle",
    "font-size": 20
  });


  //var text = svg.append("text").text("hallo")

  return {id: id, path: path, circle: circleGroup}
}

var dgraph = networkcube.getDynamicGraph();

var labels = dgraph.timeArrays.label
int_dates = labels.map(Date.parse)
gaps_in_days = [0]

for(i=0;i<int_dates.length-1;i++){
  gap = Math.round((int_dates[i+1] - int_dates[i])/86400000) //days
  gaps_in_days.push(gap)
}
console.log(gaps_in_days)

nodeSetLengthAtEachPoint = [];
for(i=0; i<dgraph.timeArrays.links.length; i++){
    let nodesAtThisPoint = new Set();
    for(j=0; j<dgraph.timeArrays.links[i].length; j++){
        nodesAtThisPoint.add( dgraph.linkArrays.source[dgraph.timeArrays.links[i][j]] )
        nodesAtThisPoint.add( dgraph.linkArrays.target[dgraph.timeArrays.links[i][j]] )
    }
    nodeSetLengthAtEachPoint.push(nodesAtThisPoint.size)
    //this could be useful later to get the connected nodes a each time point
    //Dont think this works because it only shows when new nodes are added, not when they're removedi
}
console.log(nodeSetLengthAtEachPoint)

var sum = gaps_in_days.reduce(function(a, b) { return a + b; }, 0);
step_size = gaps_in_days.length / sum

const normalised_gaps_in_days = gaps_in_days.map(x => x * step_size);
console.log(normalised_gaps_in_days)
normalised_gaps_X_coords = []
sumSoFar = 0
for(i=0;i<normalised_gaps_in_days.length;i++){
  sumSoFar += normalised_gaps_in_days[i]
  normalised_gaps_X_coords.push(sumSoFar)
}
console.log(normalised_gaps_X_coords)


numberOfLinksAtEachTimeJump = [];
timesForLinks = dgraph.timeArrays.label;
for(i=0; i < dgraph.timeArrays.links.length; i++){
    numberOfLinksAtEachTimeJump.push(dgraph.timeArrays.links[i].length);
}
function calculateDensity(edges, nodes){
  ret = []
  i = 0
  while(i < edges.length){
    ret.push( (edges[i]) / (nodes[i] * (nodes[i] - 1)) )
    i += 1
  }
  return ret
}

function getStateOfGrapghAtT(t){
  edges = dgraph.timeArrays.links[t]
  ret_edges = []
  ret_nodes = new Set([])
  for(i=0;i<edges.length;i++){
    edge = edges[i]
    source = dgraph.linkArrays.source[edge]
    target = dgraph.linkArrays.target[edge]
    ret_edges.push([source, target])
    ret_nodes.add(source)
    ret_nodes.add(target)
    //console.log("Edge "+edges[i] + " from " + source + " to " + target)
  }
  ret_nodes = Array.from(ret_nodes);
  return {"edges": ret_edges, "nodes": ret_nodes}
}

class Graph {
   constructor() {
      this.edges = {};
      this.nodes = [];
   }

   addNode(node) {
      this.nodes.push(node);
      this.edges[node] = [];
   }

   addEdge(node1, node2, weight = 1) {
      this.edges[node1].push({ node: node2, weight: weight });
      this.edges[node2].push({ node: node1, weight: weight });
   }

   floydWarshallAlgorithm() {
      let dist = {};
      let maxSoFar = 0;
      for (let i = 0; i < this.nodes.length; i++) {
         dist[this.nodes[i]] = {};
         // For existing edges assign the dist to be same as weight
         this.edges[this.nodes[i]].forEach(e => (dist[this.nodes[i]][e.node] = e.weight));
         this.nodes.forEach(n => {
            // For all other nodes assign it to infinity
            if (dist[this.nodes[i]][n] == undefined)
            dist[this.nodes[i]][n] = Infinity;
            // For self edge assign dist to be 0
            if (this.nodes[i] === n) dist[this.nodes[i]][n] = 0;
         });
      }
      this.nodes.forEach(i => {
         this.nodes.forEach(j => {
            this.nodes.forEach(k => {
               // Check if going from i to k then from k to j is better
               // than directly going from i to j. If yes then update
               // i to j value to the new value
               if (dist[i][k] + dist[k][j] < dist[i][j])
                  dist[i][j] = dist[i][k] + dist[k][j];
               });
            });
         });
         //Can also return dist for all of them
         return dist;
   }
}

function diameterOfGraphAtT(t){
  let g = new Graph();
  graph = getStateOfGrapghAtT(t)
  edges = graph['edges']
  nodes = graph['nodes']
  for(i=0;i<nodes.length;i++){
    g.addNode(nodes[i])
  }
  for(i=0;i<edges.length;i++){
    g.addEdge(edges[i][0], edges[i][1])
  }
  dist = g.floydWarshallAlgorithm()
  diameter = 0
  for(var key in dist){
    val = dist[key]
    for(var key2 in val){
      if(val[key2] > diameter && isFinite(val[key2]) ){
        diameter = val[key2]
      }
    }
  }
  //console.log(dist)
  return diameter
}

allDiameters = []
for(j=0;j<60;j++){
  allDiameters.push(diameterOfGraphAtT(j))
}
console.log(allDiameters)

function getClusterCounts(){
  console.log("CLUSTER COUNTS")
  console.log(dgraph)
  var colorCluster = hcluster()
    .distance('euclidean') // support for 'euclidean' and 'angular'
    .linkage('avg')        // support for 'avg', 'max' and 'min'
    .verbose(true)         // false by default
    .posKey('rgbValue')    // 'position' by default
}

getClusterCounts()

function convertToCoords(x){
  len = x.length
  step = Math.ceil(width / len)
  var max = x.reduce(function(a, b) {
    return Math.max(a, b);
  });
  //console.log("YEEER" + x + " " + step + " " + max )
  ret = []
  ret.push([0,50])
  for(i=0; i<normalised_gaps_X_coords.length; i++){
    scaledY = x[i] / max * 50;
    ret.push([normalised_gaps_X_coords[i]*step, 50-scaledY])
    //console.log("pushing", [normalised_gaps_X_coords[i]*step, 50-scaledY])
  }
  ret.push([len*step, 50])
  ret.push([0,50])
  //console.log(ret)
  return ret
}


var points4 = convertToCoords(allDiameters);
graph4 = drawLineGraph(points4, "purple", 3, "Diameter")

var points3 = convertToCoords(calculateDensity(numberOfLinksAtEachTimeJump, nodeSetLengthAtEachPoint));
graph3 = drawLineGraph(points3, "green", 3, "Density")

var points2 = convertToCoords(numberOfLinksAtEachTimeJump);
graph2 = drawLineGraph(points2, "blue", 2, "Links")

var points1 = convertToCoords(nodeSetLengthAtEachPoint);
graph1 = drawLineGraph(points1, "red", 1, "Nodes")

allGraphs = [graph1, graph2]


//transition();

function approximateXY(points, line, mouseX, trueLength){
  closest_point_to_cursor = points[0]
  var i;
  for(i=0; i<points.length; i++){
    if(Math.abs(mouseX - points[i][0]) < Math.abs(mouseX - closest_point_to_cursor[0])){
      closest_point_to_cursor = points[i]
    }
  }
  if(closest_point_to_cursor[0] && closest_point_to_cursor[1]){
    return {x: closest_point_to_cursor[0], y: closest_point_to_cursor[1]}
  }else{
    return {x: 0, y: 0}
  }
}

function transition(points, graph, mouseX) {

  var pathLength = graph.path.node().getTotalLength();
  //console.log("LENGTH " + pathLength)
  //console.log("WIDTH " + width)
  //console.log("HEIGHT " + 50)
  pathLength = pathLength - (2*50) - width
  //console.log("TRUE LENGTH " + pathLength)
  cursor_prcnt = mouseX / width;

  X_ = cursor_prcnt * pathLength;
  pt = graph.path.node().getPointAtLength(X_);

  //console.log("width " + width)
  //console.log("cursor_prcnt " + cursor_prcnt)
  //console.log("Expected X " + cursor_prcnt * width)
  approx = approximateXY(points, graph.path.node(), mouseX, pathLength)
  //console.log("Approximated X" + approx)
  //console.log("Actual X " + pt.x)

  //console.log("id = " + graph.id + " prcnt = " + prcnt + "x = " + pt.x + " y= " + pt.y)
  if(approx.x && approx.y){
    graph.circle.selectAll("circle").attr("transform", function(d) {
        return "translate(" + approx.x + "," + approx.y + ")"
    });
    graph.circle.selectAll("text").attr("transform", function(d) {
        graph.circle.selectAll("text").text("" + Math.round(50 - approx.y))
        return "translate(" + approx.x + "," + approx.y + ")"
    });
  }
}

function getMousePos(svg, evt) {
  return {
    x: evt.clientX,
    y: evt.clientY
  };
}

document.addEventListener('mousemove', function(evt) {
  var mousePos = getMousePos(document, evt);
  transition(points1, graph1, mousePos.x);
  transition(points2, graph2, mousePos.x);
  transition(points3, graph3, mousePos.x);
  transition(points4, graph4, mousePos.x);
}, false);

document.addEventListener('click', function(evt) {
  //can convert to timeArray first and last label
  initialTime = new Date('1960-12-13T12:00:00+00:00').getTime() / 1000
  finalTime = new Date('1992-06-03T12:00:00+01:00').getTime() / 1000
  console.log(initialTime)
  console.log(finalTime)
  console.log(event.clientX + " " + width)
  console.log(initialTime + (clientX/width * (finalTime - initialTime)))
  parent.window.networkcube.timeRange(initialTime, finalTime/2, 1, true)
}, false);



</script>
